
#---------------------------------- cut here ----------------------------------
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Matt Burdick <burdick@hpindzb> on Wed Apr 18 08:28:02 1990
#
# This archive contains:
#	accrete.pas	display.pas	enviro.pas	main.pas	
#	utils.pas	
#
# Error checking via wc(1) will be performed.
# Error checking via sum(1) will be performed.

LANG=""; export LANG
PATH=/bin:/usr/bin:$PATH; export PATH

if sum -r </dev/null >/dev/null 2>&1
then
	sumopt='-r'
else
	sumopt=''
fi

echo x - accrete.pas
cat >accrete.pas <<'@EOF'
   Procedure Set_Initial_conditions(Inner_limit_of_dust, Outer_limit_of_dust : real);
      Begin
         New (Dust_head);
         Planet_head:= nil;
         Dust_head^.Next_band:= nil;
         Dust_head^.Outer_edge:= Outer_limit_of_dust;
         Dust_head^.Inner_edge:= Inner_limit_of_dust ;
         Dust_head^.Dust_present:= true;
         Dust_head^.Gas_present:= true;
         Dust_left:= true;
      End;

   Function Stellar_dust_limit (Stellar_mass_ratio : real) : real;
      Begin
	Stellar_dust_limit:= 200.0 * power(Stellar_mass_ratio, 1/3);
      End;

   Function Innermost_planet (stellar_mass_ratio : real) : real;
      Begin
	Innermost_planet:= 0.3 * power(Stellar_mass_ratio, 1/3);
      End;

   Function Outermost_planet (stellar_mass_ratio : real) : real;
      Begin
	Outermost_planet:= 50.0 * power(Stellar_mass_ratio, 1/3);
      End;

   Procedure Update_dust_lanes (min, max, mass, crit_mass,
				body_inner_bound, body_outer_bound : real);
      VAR gas : boolean;
          Node1, Node2, Node3 : Dust_Pointer;
      Begin
         Dust_left:= false;
         If (mass > crit_mass)
            then gas:= false
            else gas:= true;
         Node1:= Dust_head;
         While (node1 <> nil) do
            Begin
               If (Node1^.inner_edge < min) and (node1^.outer_edge > max)
                  then begin
                          New (node2);
                          Node2^.inner_edge:= min;
                          Node2^.outer_edge:= max;
                          If (Node1^.gas_present = true)
                             then Node2^.Gas_present:= gas
                             else Node2^.gas_present:= false;
                          Node2^.dust_present:= false;
                          New (node3);
                          Node3^.inner_edge:= max;
                          Node3^.outer_edge:= Node1^.outer_edge;
                          Node3^.gas_present:= Node1^.gas_present;
                          Node3^.dust_present:= Node1^.dust_present;
                          Node3^.next_band:= Node1^.next_band;
                          Node1^.next_band:= Node2;
                          Node2^.next_band:= Node3;
                          Node1^.outer_edge:= min;
                          Node1:= node3^.next_band;
                       end
               else If (Node1^.inner_edge < max) and (Node1^.outer_edge > max)
                  then begin
                          New (node2);
                          Node2^.next_band:= node1^.next_band;
                          node2^.dust_present:= node1^.dust_present;
                          node2^.gas_present:= node1^.gas_present;
                          node2^.outer_edge:= node1^.outer_edge;
                          node2^.inner_edge:= max;
                          Node1^.next_band:= node2;
                          node1^.outer_edge:= max;
                          If (Node1^.gas_present = true)
                             then Node1^.Gas_present:= gas
                             else Node1^.gas_present:= false;
                          Node1^.dust_present:= false;
                          Node1:= node2^.next_band;
                       end
               else If (Node1^.inner_edge < min) and (Node1^.outer_edge > min)
                  then begin
                          New (node2);
                          Node2^.next_band:= node1^.next_band;
                          node2^.dust_present:= false;
                          If (Node1^.gas_present = true)
                             then Node2^.Gas_present:= gas
                             else Node2^.gas_present:= false;
                          node2^.outer_edge:= node1^.outer_edge;
                          node2^.inner_edge:= min;
                          Node1^.next_band:= node2;
                          node1^.outer_edge:= min;
                          node1:= node2^.next_band;
                       end
               else If (Node1^.inner_edge >= min) and (node1^.outer_edge <= max)
                  then begin
                          If (node1^.gas_present = true)
                             then Node1^.gas_present:= gas;
                          Node1^.dust_present:= false;
                          node1:= node1^.next_band;
                       end
               else if (node1^.outer_edge < min) or (node1^.inner_edge > max)
                  then node1:= node1^.next_band;
            End;
         Node1:= Dust_head;
         While (node1 <> nil) do
            Begin
               If (node1^.dust_present) and ((node1^.outer_edge >= body_inner_bound)
                  and (node1^.inner_edge <= body_outer_bound))
                  then dust_left:= true;
               node2:= node1^.next_band;
               If (node2 <> nil)
                  then begin
                          If (node1^.dust_present = node2^.dust_present)
                             and (node1^.gas_present = node2^.gas_present)
                             then begin
                                     node1^.outer_edge:= node2^.outer_edge;
                                     node1^.next_band:= node2^.next_band;
                                     dispose (node2);
                                  end;
                       end;
               node1:= node1^.next_band;
            End;
      End;

   Function Collect_dust (VAR R_inner, R_outer, reduced_mass : real;
			  last_mass, a, e, dust_density, crit_mass,
			  cloud_eccentricity : real;
                          Dust_band : Dust_pointer) : real;
      VAR Mass_density, temp1, temp2, temp, temp_density,
          bandwidth, width, volume : real;
      Begin
         temp:= last_mass/(1 + last_mass);
         Reduced_mass:= power(temp, 1/4);
         R_inner:=a*(1 - e)*(1 - reduced_mass)/(1 + Cloud_eccentricity);
         R_outer:=a*(1 + e)*(1 + reduced_mass)/(1 - Cloud_eccentricity);
         If (R_inner < 0.0) then R_inner:= 0.0;
         If (Dust_band = nil)
            then Collect_dust:= 0.0
            else begin
                    If (dust_band^.dust_present = false)
                       then temp_density:= 0.0
                       else temp_density:= dust_density;
                    If (last_mass < Crit_mass) or (dust_band^.gas_present = false)
                       then Mass_density:= temp_density
                       else Mass_density:= K * temp_density/(1 + Sqrt(Crit_mass/last_mass)*(K - 1));
                    If (dust_band^.outer_edge <= R_inner)
                       or (dust_band^.inner_edge >= R_outer)
                       then Collect_dust:= Collect_dust (R_inner, R_outer, reduced_mass,
			       last_mass, a, e, dust_density, crit_mass,
			       cloud_eccentricity, Dust_band^.next_band)
                       else begin
                               bandwidth:= (R_outer - R_inner);
                               temp1:= R_outer - Dust_band^.Outer_edge;
                               If (temp1 < 0) then temp1:= 0;
                               width:= bandwidth - temp1;
                               Temp2:= Dust_Band^.Inner_edge - R_inner;
                               If (temp2 < 0) then temp2:= 0;
                               width:= width - temp2;
                               temp:= 4 * Pi * Sqr(a) * Reduced_mass
                                      * (1 - e*(temp1 - temp2)/bandwidth);
                               volume:= temp * width;
                               Collect_dust:= volume * mass_density
                                              + Collect_dust (R_inner, R_outer, reduced_mass,
						   last_mass, a, e, dust_density, crit_mass,
						   cloud_eccentricity, Dust_band^.next_band);
                            end;
                 end;
      End;

   Function critical_limit (orbital_radius, eccentricity,
			    Stellar_luminosity_ratio : real) : real;
(*--------------------------------------------------------------------------*)
(*   Orbital radius is in AU, eccentricity is unitless, and the stellar     *)
(*  luminosity ratio is with respect to the sun.  The value returned is the *)
(*  mass at which the planet begins to accrete gas as well as dust, and is  *)
(*  in units of solar masses.                                               *)
(*--------------------------------------------------------------------------*)
      VAR temp, Perihelion_dist : real;
      Begin
         Perihelion_dist:= (orbital_radius - orbital_radius*eccentricity);
         Temp:= Perihelion_dist * Sqrt(Stellar_luminosity_ratio);
         Critical_limit:= B * power(temp, -0.75);
      End;


   Procedure Accrete_dust (VAR seed_mass, reduced_mass : real;
			   a, e, crit_mass, Stellar_mass_ratio,
			   cloud_eccentricity,
			   body_inner_bound, body_outer_bound : real);
      VAR Perihelion_dist, new_mass, temp_mass, dust_density,
	  R_inner, R_outer : real;
      Begin
         Dust_density:= Dust_density_coeff * Sqrt(Stellar_mass_ratio)*
            Exp(-alpha*power(a, 1/N));
(*         Crit_mass:= critical_limit (a, e, Stellar_luminosity_ratio);*)
         New_mass:= seed_mass;
         Repeat
            temp_mass:= new_mass;
            new_mass:= collect_dust (R_inner, R_outer, reduced_mass, new_mass,
		 a, e, dust_density, crit_mass, cloud_eccentricity, Dust_head);
          Until ((new_mass - temp_mass) < (0.0001 * temp_mass));
         Seed_Mass:= seed_mass + new_mass;
         Update_dust_lanes (R_inner, R_outer, seed_mass, crit_mass,
			body_inner_bound, body_outer_bound);
      End;

   Procedure Coalesce_planetesimals (VAR reduced_mass : real;
		a, e, mass, crit_mass,
		Stellar_mass_ratio, Stellar_luminosity_ratio,
		cloud_eccentricity,
		body_inner_bound, body_outer_bound : real);
      VAR node1, node2, node3 : planet_pointer;
          coalesced : boolean;
          temp, Dist1, Dist2, a3 : real;
      Begin
         Coalesced:= false;
         node1:= planet_head;
         While (node1 <> nil) do
            begin
               node2:= node1;
               temp:= node1^.a - a;
               If (temp > 0)
                  then begin
                          Dist1:= (a*(1 + e)*(1 + reduced_mass)) - a;  (* x aphelion   *)
                          reduced_mass:= power(node1^.mass/(1 + node1^.mass), 1/4);
                          Dist2:= node1^.a - (node1^.a*(1 - node1^.e)*(1 - reduced_mass));
                       end
                  else begin
                          Dist1:= a - (a*(1 - e)*(1 - reduced_mass));  (* x perihelion *)
                          reduced_mass:= power(node1^.mass/(1 + node1^.mass), 1/4);
                          Dist2:= (node1^.a*(1 + node1^.e)*(1 + reduced_mass)) - node1^.a;
                       end;
               If (Abs(temp) <= Abs(Dist1)) or (Abs(temp) <= Abs(Dist2))
                  then begin
{                          writeln(^G, 'SMASH!');}
                          writeln('SMASH!');
                          a3:= (node1^.mass + mass)/((node1^.mass/node1^.a) + (mass/a));
                          temp:= node1^.mass * sqrt(node1^.a) * sqrt(1 - sqr(node1^.e));
                          temp:= temp + (mass * sqrt(a) * sqrt(sqrt(1 - sqr(e))));
                          temp:= temp/((node1^.mass + mass) * sqrt(a3));
                          temp:= 1 - Sqr(temp);
                          If (temp < 0.0) or (temp >= 1.0)
                             then temp:= 0.0;
                          e:= Sqrt(temp);
                          temp:= node1^.mass + mass;
                          Accrete_dust (temp, reduced_mass, a3, e,
				Stellar_mass_ratio, Stellar_luminosity_ratio,
				cloud_eccentricity,
				body_inner_bound, body_outer_bound);
                          node1^.a:= a3;
                          node1^.e:= e;
                          node1^.mass:= temp;
                          node1:= nil;
                          coalesced:= true;
                       end
                  else Node1:= node1^.next_planet;
            end;
         If not coalesced
            then begin
                    New (node3);
                    node3^.a:= a;
                    node3^.e:= e;
                    If (mass >= crit_mass)
                       then node3^.gas_giant:= true
                       else node3^.gas_giant:= false;
                    node3^.mass:= mass;
                    If (Planet_head = nil)
                       then begin
                               Planet_head:= node3;
                               node3^.next_planet:= nil;
                            end
                       else begin
                               node1:= planet_head;
                               If (a < node1^.a)
                                  then begin
                                          node3^.next_planet:= node1;
                                          planet_head:= node3;
                                       end
                                  else If (planet_head^.next_planet = nil)
                                    then begin
                                            planet_head^.next_planet:= node3;
                                            node3^.next_planet:= nil;
                                         end
                                    else begin
                                            while (node1 <> nil) and (node1^.a < a)
                                               do begin
                                                     node2:= node1;
                                                     node1:= node1^.next_planet;
                                                  end;
                                            node3^.next_planet:= node1;
                                            node2^.next_planet:= node3;
                                         end;
                            end;
                 end;
      End;

   Function Distribute_planetary_masses (stellar_mass_ratio,
                                         Stellar_luminosity_ratio,
					 inner_dust, outer_dust : real) : planet_pointer;
      VAR a, e, mass, crit_mass, reduced_mass, cloud_eccentricity,
	       Planetesimal_inner_bound, Planetesimal_outer_bound : real;
      Begin
         Set_initial_conditions(inner_dust, outer_dust);
         While dust_left do
            Begin
{         Cloud_eccentricity:= Random_eccentricity;}
	       Cloud_eccentricity:= 0.2;
               mass:= protoplanet_mass;
	       Planetesimal_inner_bound:= Innermost_planet(stellar_mass_ratio);
	       Planetesimal_outer_bound:= Outermost_planet(stellar_mass_ratio);
               a:= Random_number (Planetesimal_inner_bound, Planetesimal_outer_bound);
               e:= Random_eccentricity;
               Crit_mass:= critical_limit (a, e, Stellar_luminosity_ratio);
               Accrete_dust (mass, reduced_mass, a, e, crit_mass,
			Stellar_mass_ratio, cloud_eccentricity,
			Planetesimal_inner_bound, Planetesimal_outer_bound);
               If (mass <> 0.0) and (mass <> protoplanet_mass)
                  then Coalesce_planetesimals (reduced_mass, a, e, mass, crit_mass,
			Stellar_mass_ratio, Stellar_luminosity_ratio,
			cloud_eccentricity,
			Planetesimal_inner_bound, Planetesimal_outer_bound);
            End;
	 Distribute_planetary_masses := planet_head;
      End;

   Function Distribute_moon_masses (Planetary_mass, Stellar_luminosity_ratio,
	planet_eccentricity,
	inner_dust, outer_dust : real) : planet_pointer;
      VAR a, e, mass, crit_mass, reduced_mass, cloud_eccentricity,
	       Planetesimal_inner_bound, Planetesimal_outer_bound : real;
      Begin
(*         Set_initial_conditions(inner_dust, outer_dust);
         While dust_left do
            Begin
	       Cloud_eccentricity:= 0.2;
               mass:= protomoon_mass;
	       Planetesimal_inner_bound:= Innermost_planet(planetary_mass);
	       Planetesimal_outer_bound:= Outermost_planet(planetary_mass);
               a:= Random_number (Planetesimal_inner_bound, Planetesimal_outer_bound);
               e:= Random_eccentricity;
               Crit_mass:= critical_limit (a, planet_eccentricity,
			Stellar_luminosity_ratio);
               Accrete_dust (mass, reduced_mass, a, e, crit_mass,
			Stellar_mass_ratio, cloud_eccentricity,
			Planetesimal_inner_bound, Planetesimal_outer_bound);
               If (mass <> 0.0) and (mass <> protoplanet_mass)
                  then Coalesce_planetesimals (reduced_mass, a, e, mass, crit_mass,
			planetary_mass, Stellar_luminosity_ratio,
			cloud_eccentricity,
			Planetesimal_inner_bound, Planetesimal_outer_bound);
            End;
	 Distribute_moon_masses := planet_head;*)
      End;

@EOF
set `sum $sumopt <accrete.pas`; if test $1 -ne 58460
then
	echo ERROR: accrete.pas checksum is $1 should be 58460
fi
set `wc -lwc <accrete.pas`
if test $1$2$3 != 350112816600
then
	echo ERROR: wc results of accrete.pas are $* should be 350 1128 16600
fi

chmod 644 accrete.pas

echo x - display.pas
cat >display.pas <<'@EOF'
   Procedure Display_system;
      VAR node1 : planet_pointer;
          counter : integer;
          word : string[10];
      Begin
{         sound (2000);}
{         ClrScr;}
         Writeln ('                         SYSTEM  CHARACTERISTICS');
         Str(stellar_mass_ratio:4:2,word);
         writeln ('Mass of central star (in solar masses): ',word);
         Str(stellar_luminosity_ratio:5:2,word);
         writeln ('Luminosity of central star (relative to the sun): ', word);
         str(main_seq_life/1.0E6:10:3,word);
         writeln ('Total main sequence lifetime (in million yrs): ', word);
         str(age/1.0E6:10:3,word);
         writeln ('Current age of stellar system (in million yrs): ',word);
         str(r_ecosphere:3:3,word);
         Writeln ('Radius of habitable ecosphere (AU): ',word);
{         nosound;}
{         repeat until keypressed;}
         node1:= planet_head;
         counter:= 1;
         while (node1 <> nil)
          do begin
                writeln ('Planet #',counter,':');
                If (node1^.gas_giant)
                   then writeln ('Gas giant...');
                If (node1^.resonant_period)
                   then writeln ('In resonant period with primary.');
                str(node1^.a:7:3,word);
                Writeln ('   Distance from primary star (in A.U.): ',word);
                str(node1^.e:5:3,word);
                writeln ('   Eccentricity of orbit: ',word);
                str(node1^.mass*Earth_masses_per_solar_mass:7:3,word);
                writeln ('   Mass (in Earth masses): ',word);
                str(node1^.radius:10:1,word);
                writeln ('   Equatorial radius (in Km): ',word);
                str(node1^.density:6:3,word);
                writeln ('   Density (in g/cc): ',word);
                str(node1^.escape_velocity/cm_per_km:5:2, word);
                writeln ('   Escape Velocity (in km/sec): ',word);
                str(node1^.molecule_weight:5:2, word);
                writeln ('   Smallest molecular weight retained: ',word);
                str(node1^.surface_accel:6:2, word);
                writeln ('   Surface acceleration (in cm/sec2): ',word);
                If not(node1^.gas_giant)
                   then begin
                           str(node1^.surface_grav:5:2, word);
                           writeln ('   Surface Gravity (in Earth gees): ',word);
                           str((node1^.boil_point - Kelvin_Celcius_difference):4:1, word);
                           writeln ('   Boiling point of water (celcius): ',word);
                           str((node1^.surface_pressure / 1000.0):5:3, word);
                           write ('   Surface Pressure (in atmospheres): ',word);
                           if ((node1^.greenhouse_effect) and (node1^.surface_pressure > 0.0))
                              then writeln( '     RUNAWAY GREENHOUSE EFFECT')
                              else writeln(' ');
                           str((node1^.surface_temp - Kelvin_Celcius_difference):4:2, word);
                           writeln ('   Surface temperature (Celcius): ',word);
                           str((node1^.hydrosphere * 100.0):6:2, word);
                           writeln ('   Hydrosphere percentage: ',word);
                           str((node1^.cloud_cover * 100):6:2, word);
                           writeln ('   Cloud cover percentage: ',word);
                           str((node1^.ice_cover * 100):6:2, word);
                           writeln ('   Ice cover percentage: ',word);
                        end;
                writeln ('   Axial tilt (in degrees): ',node1^.axial_tilt);
                str(node1^.albedo:4:3, word);
                writeln ('   Planetary albedo: ',word);
{                CASE (node1^.atmosphere) of
                   0 : writeln ( '   No appreciable atmosphere.');
                   1 : writeln ( '   Nitrogen/Oxygen atmosphere.');
                   2 : writeln ( '   Carbon dioxide/Nitrogen atmosphere with trace elements.');
                   3 : writeln ( '   Nitrogen and Hydrocarbon atmosphere.');
                   4 : writeln ( '   Methane and Nitrogen atmosphere.');
                   5 : writeln ( '   Nitrogen/Carbon dioxide/Methane atmosphere.');
                   6 : writeln ( '   Highly oxidised Sulphur/Nitrogen dioxide atmosphere.');
                   7 : writeln ( '   Helium and sublimated frozen gasses atmosphere.');
                   8 : writeln ( '   Gas giant atmosphere.');
                end;}
                str(node1^.orbital_period:7:2, word);
                writeln ('   Length of year (in days): ',word);
                str(node1^.day:7:2, word);
                writeln ('   Length of day (in hours): ',word);

                counter:= counter + 1;
                node1:= node1^.next_planet;
             end;
      End;
@EOF
set `sum $sumopt <display.pas`; if test $1 -ne 48668
then
	echo ERROR: display.pas checksum is $1 should be 48668
fi
set `wc -lwc <display.pas`
if test $1$2$3 != 883954872
then
	echo ERROR: wc results of display.pas are $* should be 88 395 4872
fi

chmod 644 display.pas

echo x - enviro.pas
cat >enviro.pas <<'@EOF'
   Function Luminosity (mass_ratio : real) : real;
      VAR N : real;
      Begin
         If (mass_ratio < 1.0)
            then N:= 1.75*(mass_ratio - 0.1) + 3.325
            else N:= 0.5*(2.0 - mass_ratio) + 4.4;
         Luminosity:= Power (mass_ratio, N);
      End;

   Function Orbital_zone (orbital_radius : real) : integer;
(*--------------------------------------------------------------------------*)
(*   This function, given the orbital radius of a planet in AU, returns     *)
(*   the orbital 'zone' of the particle.                                    *)
(*--------------------------------------------------------------------------*)
      Begin
         If (orbital_radius < (4 * sqrt(Stellar_luminosity_ratio)))
            then Orbital_zone:= 1
            else begin
                    if (orbital_radius >= (4 * sqrt(Stellar_luminosity_ratio)))
                        and (orbital_radius < (15 * sqrt(Stellar_luminosity_ratio)))
                       then Orbital_zone:= 2
                       else Orbital_zone:= 3;
                 end;
      End;

   Function Volume_radius (mass, density : real) : real;
(*--------------------------------------------------------------------------*)
(*   The mass is in units of solar masses, and the density is in units      *)
(*   of grams/cc.  The radius returned is in units of km.                   *)
(*--------------------------------------------------------------------------*)
      VAR volume : real;
      Begin
         mass:= mass * solar_mass_in_grams;
         volume:= mass / density;
         Volume_radius:= power((3.0 * volume)/(4.0 * Pi),1/3) / cm_per_km;
      End;

   Function Kothari_radius (mass, orbital_radius : real;
                           giant : boolean;
                           zone : integer) :real;
(*--------------------------------------------------------------------------*)
(*    Returns the radius of the planet in kilometers.                       *)
(*   The mass passed in is in units of solar masses, the orbital radius     *)
(*   in A.U.                                                                *)
(*   This formula is listed as eq.9 in Fogg's article, although some typos  *)
(*   crop up in that eq.  See "The Internal Constitution of Planets", by    *)
(*   Dr. D. S. Kothari, Mon. Not. of the Royal Astronomical Society, vol 96 *)
(*   pp.833-843, 1936 for the derivation.  Specifically, this is Kothari's  *)
(*   eq.23, which appears on page 840.                                      *)
(*--------------------------------------------------------------------------*)
      VAR temp, temp2, atomic_weight, atomic_num : real;
      CONST a1 = 6.485E12;      (* All units are in cgs system.  *)
            a2 = 4.0032E-8;     (*   ie: cm, g, dynes, etc.      *)
            Beta = 5.71E12;
      Begin
         If (zone = 1)
            then begin
                    If giant then begin
                                     atomic_weight:= 9.5;
                                     atomic_num:= 4.5;
                                  end
                             else begin
                                     atomic_weight:= 15.0;
                                     atomic_num:= 8.0;
                                  end;
                 end
            else if (zone = 2)
                    then begin
                            If giant then begin
                                             atomic_weight:= 2.47;
                                             atomic_num:= 2.0;
                                          end
                                      else begin
                                              atomic_weight:= 10.0;
                                              atomic_num:= 5.0;
                                           end;
                         end
                    else begin
                            If giant then begin
                                             atomic_weight:=7.0;
                                             atomic_num:= 4.0;
                                          end
                                     else begin
                                             atomic_weight:= 10.0;
                                             atomic_num:= 5.0;
                                          end;
                         end;
         temp:= atomic_weight*atomic_num;
         temp:= (2.0*Beta*power(Solar_mass_in_grams, 1/3))/(a1*power(temp, 1/3));
         temp2:= a2*power(atomic_weight, 4/3)*power(Solar_mass_in_grams, 2/3);
         temp2:= temp2 * power(mass, 2/3);
         temp2:= temp2 / (a1*Sqr(atomic_num));
         temp2:= 1 + temp2;
         temp:= temp / temp2;
         temp:= (temp * power(mass, 1/3)) / cm_per_km;
         Kothari_radius:= temp;
      End;

   Function Empirical_density (mass, Orbital_radius : real;
                            gas_giant : boolean ) : real;
(*--------------------------------------------------------------------------*)
(*  The mass passed in is in units of solar masses, and the orbital radius  *)
(*  is in units of AU.  The density is returned in units of grams/cc.       *)
(*--------------------------------------------------------------------------*)
      VAR temp : real;
      Begin
         temp:= power (mass*Earth_masses_per_solar_mass, 1/8);
         temp:= temp * power(R_ecosphere/Orbital_radius, 1/4);
         If (gas_giant)
            then Empirical_density:= temp * 1.2
            else Empirical_density:= temp * 5.5;
      End;

   Function Volume_density (mass, equatorial_radius : real) : real;
(*--------------------------------------------------------------------------*)
(*  The mass passed in is in units of solar masses, and the equatorial      *)
(*  radius is in km.  The density is returned in units of grams/cc.         *)
(*--------------------------------------------------------------------------*)
      VAR volume : real;
      Begin
         mass:= mass * solar_mass_in_grams;
         equatorial_radius:= equatorial_radius * cm_per_km;
         volume:= (4.0 * Pi * power(equatorial_radius, 3.0))/3.0;
         Volume_density:= mass / volume;
      End;

   Function Period (separation, small_mass, large_mass : real) : real;
(*--------------------------------------------------------------------------*)
(*  The separation is in units of AU, and both masses are in units of solar *)
(*  masses.  The period returned is in terms of Earth days.                 *)
(*--------------------------------------------------------------------------*)
      VAR period_in_years : real;
      Begin
         period_in_years:= sqrt ( power(separation, 3.0) /
                                  (small_mass + large_mass) );
         Period:= period_in_years * days_in_a_year;
      End;

   Function Day_length (mass, radius, orbital_period, eccentricity : real;
                        giant : boolean) : real;
(*--------------------------------------------------------------------------*)
(*   Fogg's information for this routine came from Dole "Habitable Planets  *)
(* for Man", Blaisdell Publishing Company, NY, 1964.  From this, he came    *)
(* up with his eq.12, which is the equation for the base_angular_velocity   *)
(* below.  Going a bit further, he found an equation for the change in      *)
(* angular velocity per time (dw/dt) from P. Goldreich and S. Soter's paper *)
(* "Q in the Solar System" in Icarus, vol 5, pp.375-389 (1966).  Comparing  *)
(* to the change in angular velocity for the Earth, we can come up with an  *)
(* approximation for our new planet (his eq.13) and take that into account. *)
(*--------------------------------------------------------------------------*)
      VAR base_angular_velocity, planetary_mass_in_grams,
          k2, equatorial_radius_in_cm, change_in_angular_velocity,
          spin_resonance_period, temp : real;
      Begin
         spin_resonance:= FALSE;
         If giant
            then k2:= 0.24
            else k2:= 0.33;
         planetary_mass_in_grams:= mass * Solar_mass_in_grams;
         equatorial_radius_in_cm:= radius * cm_per_km;
         base_angular_velocity:= sqrt(2.0 * j * (planetary_mass_in_grams)
                                      / (k2 * sqr(equatorial_radius_in_cm)));
(* not done here.  Try to add the dw/dt stuff after finding out what Q' is *)
         change_in_angular_velocity:= 0.0;
         temp:= base_angular_velocity + (change_in_angular_velocity * age);
(* temp is now the angular velocity. Change from rad/sec now to hours/rotation *)
         temp:= 1.0 / ((temp / radians_per_rotation) * seconds_per_hour);
         If (temp >= orbital_period)
            then begin
                    spin_resonance_period:= ((1.0 - eccentricity) /
                          (1.0 + eccentricity)) * orbital_period;
                   if (eccentricity > 0.1)
                       then begin
                               temp:= spin_resonance_period;
                               spin_resonance:= TRUE;
                            end
                       else temp:= orbital_period;
                 end;
         Day_length:= temp;
      End;

   Function inclination (orbital_radius : real) : integer;
(*--------------------------------------------------------------------------*)
(*   The orbital radius is expected in units of Astronomical Units (AU).    *)
(*   Inclination is returned in units of degrees.                           *)
(*--------------------------------------------------------------------------*)
      VAR temp : integer;
      Begin
         temp:= trunc(power(orbital_radius, 0.2) * about(Earth_axial_tilt, 0.4));
         inclination:= (temp mod 360);
      End;

   Function Escape_vel (mass, radius : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function implements the escape velocity calculation.  Note that   *)
(*  it appears that Fogg's eq.15 is incorrect.                              *)
(*  The mass is in units of solar mass, the radius in kilometers, and the   *)
(*  velocity returned is in cm/sec.                                         *)
(*--------------------------------------------------------------------------*)
      VAR mass_in_grams, radius_in_cm : real;
      Begin
         mass_in_grams:= mass * Solar_mass_in_grams;
         radius_in_cm:= radius * cm_per_km;
         Escape_vel:= sqrt(2 * Grav_constant * mass_in_grams / radius_in_cm);
      End;

   Function RMS_vel (molecular_weight, orbital_radius : real) : real;
(*--------------------------------------------------------------------------*)
(*  This is Fogg's eq.16.  The molecular weight (usually assumed to be N2)  *)
(*  is used as the basis of the Root Mean Square velocity of the molecule   *)
(*  or atom.  The velocity returned is in cm/sec.                           *)
(*--------------------------------------------------------------------------*)
   VAR exospheric_temp : real;
   Begin
      exospheric_temp:= Earth_exosphere_temp / Sqr(orbital_radius);
      RMS_vel:= Sqrt((3.0 * Molar_Gas_const * exospheric_temp)/
                molecular_weight) * cm_per_meter;
   End;

   Function Molecule_limit (orbital_radius, mass, equatorial_radius : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function returns the smallest molecular weight retained by the    *)
(*  body, which is useful for determining the atmosphere composition.       *)
(*  Orbital radius is in A.U.(ie: in units of the earth's orbital radius),  *)
(*  mass is in units of solar masses, and equatorial radius is in units of  *)
(*  kilometers.                                                             *)
(*--------------------------------------------------------------------------*)
      VAR numerator, denominator1, denominator2,
          escape_velocity, temp : real;
      Begin
         escape_velocity:= escape_vel(mass, equatorial_radius);
         molecule_limit:= (3.0 * sqr(gas_retention_threshold * cm_per_meter)
                          * Molar_gas_const * earth_exosphere_temp)
                          /sqr(escape_velocity);
{         numerator:= (2.0 * sqr(gas_retention_threshold) * Bolzmann_const *
                     earth_exosphere_temp);
         denominator1:= sqr(orbital_radius);
         denominator2:= sqr(escape_velocity);
         temp:= numerator/denominator1;
         Molecule_limit:= temp/denominator2;}
      End;

   Function Acceleration (mass, radius : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function calculates the surface acceleration of a planet.  The    *)
(*  mass is in units of solar masses, the radius in terms of km, and the    *)
(*  acceleration is returned in units of cm/sec2.                           *)
(*--------------------------------------------------------------------------*)
   Begin
      acceleration:= Grav_constant * (mass * solar_mass_in_grams)
                           /sqr(radius * cm_per_km);
   End;

   Function gravity (acceleration : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function calculates the surface gravity of a planet.  The         *)
(*  acceleration is in units of cm/sec2, and the gravity is returned in     *)
(*  units of Earth gravities.                                               *)
(*--------------------------------------------------------------------------*)
   Begin
      gravity:= acceleration / Earth_acceleration;
   End;

   Function Greenhouse (zone : integer;
                        orbital_radius, greenhouse_radius : real) : boolean;
(*--------------------------------------------------------------------------*)
(*  Note that if the orbital radius of the planet is greater than or equal  *)
(*  to R_inner, 99% of it's volatiles are assumed to have been deposited in *)
(*  surface reservoirs (otherwise, it suffers from the greenhouse effect).  *)
(*--------------------------------------------------------------------------*)
      Begin
         If ((orbital_radius < greenhouse_radius) and (zone = 1))
            then greenhouse:= true
            else greenhouse:= false;
      End;

   Function Vol_inventory (mass, escape_vel, RMS_vel, stellar_mass : real;
                           zone : integer;
                           greenhouse_effect : boolean ) : real;
(*--------------------------------------------------------------------------*)
(*  This implements Fogg's eq.17.  The 'inventory' returned is unitless.    *)
(*--------------------------------------------------------------------------*)
      VAR velocity_ratio, proportion_const, temp1, temp2,
          mass_in_earth_units : real;
      Begin
         velocity_ratio:= escape_vel / RMS_vel;
         If (velocity_ratio >= gas_retention_threshold)
            then begin
                    CASE zone of
                      1 : proportion_const:= 100000.0;
                      2 : proportion_const:= 75000.0;
                      3 : proportion_const:= 250.0;
                      else writeln(^G,'Error: orbital zone not initialized correctly!');
                    END;
                    mass_in_earth_units:= mass * earth_masses_per_solar_mass;
                    temp1:=(proportion_const * mass_in_earth_units) / stellar_mass;
                    temp2:= about(temp1, 0.2);
                    If (greenhouse_effect)
                       then vol_inventory:= temp2
                       else vol_inventory:= temp2 / 100.0;
                 end
            else vol_inventory:= 0.0;
      End;

   Function Pressure (volatile_gas_inventory, equatorial_radius,
                      gravity : real) : real;
(*--------------------------------------------------------------------------*)
(*  This implements Fogg's eq.18.  The pressure returned is in units of     *)
(*  millibars (mb).  The gravity is in units of Earth gravities, the radius *)
(*  in units of kilometers.                                                 *)
(*--------------------------------------------------------------------------*)
   Begin
      equatorial_radius:= earth_radius_in_km / equatorial_radius;
      Pressure:= volatile_gas_inventory * gravity / Sqr(equatorial_radius);
   End;

{   Function Atmosphere_type (pressure, age : real;
                             giant : boolean) : integer;
      Begin
         If (giant)
            then atmosphere_type:= 8
            else If (pressure = 0.0)
                    then Atmosphere_type:= 0
                    else begin
                         end;
      End;}

   Function Boiling_point (surface_pressure : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function returns the boiling point of water in an atmosphere of   *)
(*   pressure 'surface_pressure', given in millibars.  The boiling point is *)
(*   returned in units of Kelvin.  This is Fogg's eq.21.                    *)
(*--------------------------------------------------------------------------*)
      VAR surface_pressure_in_bars : real;
      Begin
         surface_pressure_in_bars:= surface_pressure / millibars_per_bar;
         boiling_point:= 1.0 / (Ln(surface_pressure_in_bars)/-5050.5
                                    + 1.0/373);
      End;

   Function hydrosphere_fraction (volatile_gas_inventory, planetary_radius : real) : real;
(*--------------------------------------------------------------------------*)
(*   This function is Fogg's eq.22.  Given the volatile gas inventory and   *)
(*   planetary radius of a planet (in Km), this function returns the        *)
(*   fraction of the planet covered with water.                             *)
(*   I have changed the function very slightly:  the fraction of Earth's    *)
(*   surface covered by water is 71%, not 75% as Fogg used.                 *)
(*--------------------------------------------------------------------------*)
      VAR temp : real;
      Begin
         temp:= (0.71 * volatile_gas_inventory / 1000.0) *
               Sqr(Earth_radius_in_km / planetary_radius);
         If (temp >= 1.0)
            then hydrosphere_fraction:= 1.0
            else hydrosphere_fraction:= temp;
      End;

   Function Cloud_fraction (surface_temp,
                            smallest_molecular_weight_retained,
                            equatorial_radius,
                            hydrosphere_fraction : real) : real;
(*--------------------------------------------------------------------------*)
(*   Given the surface temperature of a planet (in Kelvin), this function   *)
(*   returns the fraction of cloud cover available.  This is Fogg's eq.23.  *)
(*   See Hart in "Icarus" (vol 33, pp23 - 39, 1978) for an explanation.     *)
(*   This equation is Hart's eq.3.                                          *)
(*   I have modified it slightly using constants and relationships from     *)
(*   Glass's book "Introduction to Planetary Geology", p.46.                *)
(*--------------------------------------------------------------------------*)
      CONST Q1 = 1.258E19;   { grams    }
            Q2 = 0.0698;     { 1/Kelvin }
      VAR water_vapor_in_kg, fraction, surface_area,
          hydrosphere_mass : real;
      Begin
         If (smallest_molecular_weight_retained > water_vapor)
            then cloud_fraction:= 0.0
            else begin
                    surface_area:= 4.0 * Pi * Sqr(equatorial_radius);
{                    water_vapor_in_grams:= Q1 * exp(Q2 * (surface_temp - 288.0));}
                    hydrosphere_mass:= hydrosphere_fraction * surface_area
                                       * Earth_water_mass_per_area;
                    water_vapor_in_kg:= (0.00000001 * hydrosphere_mass)
                                            * exp(Q2 * (surface_temp - 288.0));
                    fraction:= Earth_area_covered_per_kg_of_cloud *
                              water_vapor_in_kg / surface_area;
                    if (fraction >= 1.0)
                       then cloud_fraction:= 1.0
                       else cloud_fraction:= fraction;
                 end;
      End;

   Function Ice_fraction (hydrosphere_fraction, surface_temp : real) : real;
(*--------------------------------------------------------------------------*)
(*   Given the surface temperature of a planet (in Kelvin), this function   *)
(*   returns the fraction of the planet's surface covered by ice.  This is  *)
(*   Fogg's eq.24.  See Hart[24] in Icarus vol.33, p.28 for an explanation. *)
(*   I have changed a constant from 70 to 90 in order to bring it more in   *)
(*   line with the fraction of the Earth's surface covered with ice, which  *)
(*   is approximatly .016 (=1.6%).                                          *)
(*--------------------------------------------------------------------------*)
      VAR temp : real;
      Begin
{         temp:= power(((328.0 - surface_temp) / 70.0),5.0);}
         temp:= power(((328.0 - surface_temp) / 90.0),5.0);
         if (temp > (1.5 * hydrosphere_fraction))
            then temp:= (1.5 * hydrosphere_fraction);
         if (temp >= 1.0)
            then ice_fraction:= 1.0
            else ice_fraction:= temp;
      End;

   Function Eff_temp (ecosphere_radius, orbital_radius, albedo : real) : real;
(*--------------------------------------------------------------------------*)
(*  This is Fogg's eq.19.  The ecosphere radius is given in AU, the orbital *)
(*  in AU, and the temperature returned is in Kelvin.                       *)
(*--------------------------------------------------------------------------*)
      Begin
         Eff_temp:= Sqrt(ecosphere_radius / orbital_radius) *
            power((1-albedo)/0.7, 0.25) * Earth_effective_temp;
      End;

   Function Green_rise (optical_depth, effective_temp,
                        surface_pressure : real) : real;
(*--------------------------------------------------------------------------*)
(*  This is Fogg's eq.20, and is also Hart's eq.20 in his "Evolution of     *)
(*  Earth's Atmosphere" article.  The effective temperature given is in     *)
(*  units of Kelvin, as is the rise in temperature produced by the          *)
(*  greenhouse effect, which is returned.                                   *)
(*--------------------------------------------------------------------------*)
      VAR convection_factor : real;
      Begin
         convection_factor:= Earth_convection_factor
           * power((surface_pressure / Earth_surface_pressure_in_millibars), 0.25);
         Green_rise:= (power((1 + 0.75*optical_depth), 0.25) - 1) *
                           effective_temp * convection_factor;
      End;

   Function Planet_albedo (water_fraction, cloud_fraction, ice_fraction,
                           surface_pressure : real) : real;
(*--------------------------------------------------------------------------*)
(*   The surface temperature passed in is in units of Kelvin.               *)
(*   The cloud adjustment is the fraction of cloud cover obscuring each     *)
(*   of the three major components of albedo that lie below the clouds.     *)
(*--------------------------------------------------------------------------*)
      VAR rock_fraction, cloud_adjustment, components, cloud_contribution,
          rock_contribution, water_contribution, ice_contribution : real;
      Begin
         rock_fraction:= 1.0 - water_fraction - ice_fraction;
         components:= 0.0;
         if (water_fraction > 0.0) then components:= components + 1;
         if (ice_fraction > 0.0) then components:= components + 1;
         if (rock_fraction > 0.0) then components:= components + 1;
         cloud_adjustment:= cloud_fraction / components;
         if (rock_fraction >= cloud_adjustment)
            then rock_fraction:= rock_fraction - cloud_adjustment
            else rock_fraction:= 0.0;
         if (water_fraction > cloud_adjustment)
            then water_fraction:= water_fraction - cloud_adjustment
            else water_fraction:= 0.0;
         if (ice_fraction > cloud_adjustment)
            then ice_fraction:= ice_fraction - cloud_adjustment
            else ice_fraction:= 0.0;
         cloud_contribution:= cloud_fraction * about(cloud_albedo, 0.2);
         if (surface_pressure = 0.0)
            then rock_contribution:= rock_fraction * about(airless_rocky_albedo, 0.3)
            else rock_contribution:= rock_fraction * about(rocky_albedo, 0.1);
         water_contribution:= water_fraction * about(water_albedo, 0.2);
         if (surface_pressure = 0.0)
            then ice_contribution:= ice_fraction * about(airless_ice_albedo, 0.4)
            else ice_contribution:= ice_fraction * about(ice_albedo, 0.1);
         planet_albedo:= cloud_contribution + rock_contribution
                         + water_contribution + ice_contribution;
      End;

   Function Opacity (molecular_weight, surface_pressure : real) : real;
(*--------------------------------------------------------------------------*)
(*   This funtion returns the dimensionless quantity of optical depth,      *)
(*   which is usefull in determining the amount of greenhouse effect on a   *)
(*   planet.                                                                *)
(*--------------------------------------------------------------------------*)
      VAR optical_depth : real;
      Begin
         optical_depth:= 0.0;
         if ((molecular_weight >= 0.0) and (molecular_weight < 10.0))
            then optical_depth:= optical_depth + 3.0;
         if ((molecular_weight >= 10.0) and (molecular_weight < 20.0))
            then optical_depth:= optical_depth + 2.34;
         if ((molecular_weight >= 20.0) and (molecular_weight < 30.0))
            then optical_depth:= optical_depth + 1.0;
         if ((molecular_weight >= 30.0) and (molecular_weight < 45.0))
            then optical_depth:= optical_depth + 0.15;
         if ((molecular_weight >= 45.0) and (molecular_weight < 100.0))
            then optical_depth:= optical_depth + 0.05;
         if (surface_pressure >= (70 * Earth_surface_pressure_in_millibars))
            then optical_depth:= optical_depth * 8.333
            else if (surface_pressure >= (50 * Earth_surface_pressure_in_millibars))
               then optical_depth:= optical_depth * 6.666
            else if (surface_pressure >= (30 * Earth_surface_pressure_in_millibars))
               then optical_depth:= optical_depth * 3.333
            else if (surface_pressure >= (10 * Earth_surface_pressure_in_millibars))
               then optical_depth:= optical_depth * 2.0
            else if (surface_pressure >= (5 * Earth_surface_pressure_in_millibars))
               then optical_depth:= optical_depth * 1.5;
         opacity:= optical_depth;
      End;

   Procedure Determine_albedo_and_surface_temp (VAR planet : planet_pointer);
(*--------------------------------------------------------------------------*)
(*   The temperature calculated is in degrees Kelvin.                       *)
(*   Quantities already known which are used in these calculations:         *)
(*       planet^.molecule_weight                                            *)
(*       planet^.surface_pressure                                           *)
(*       R_ecosphere                                                        *)
(*       planet^.a                                                          *)
(*       planet^.volatile_gas_inventory                                     *)
(*       planet^.radius                                                     *)
(*       planet^.boil_point                                                 *)
(*--------------------------------------------------------------------------*)
      VAR surface_temp, effective_temp, greenhouse_rise, previous_temp,
          optical_depth, albedo, water, clouds, ice : real;
      Begin
         optical_depth:= opacity(planet^.molecule_weight, planet^.surface_pressure);
         effective_temp:= Eff_temp(R_ecosphere, planet^.a, Earth_albedo);
         greenhouse_rise:= Green_rise(optical_depth, effective_temp,
                           planet^.surface_pressure);
         surface_temp:= effective_temp + greenhouse_rise;
         Repeat
            previous_temp:= surface_temp;
            water:= hydrosphere_fraction(planet^.volatile_gas_inventory, planet^.radius);
            clouds:= Cloud_fraction(surface_temp, planet^.molecule_weight,
                               planet^.radius, water);
            ice:= Ice_fraction(water, surface_temp);
            If (  (surface_temp >= planet^.boil_point)
               or (surface_temp <= freezing_point_of_water))
              then water:= 0.0;
            albedo:= planet_albedo(water, clouds, ice, planet^.surface_pressure);
            optical_depth:= opacity(planet^.molecule_weight, planet^.surface_pressure);
            effective_temp:= Eff_temp(R_ecosphere, planet^.a, albedo);
            greenhouse_rise:= Green_rise(optical_depth, effective_temp,
                              planet^.surface_pressure);
            surface_temp:= effective_temp + greenhouse_rise;
         Until (abs(surface_temp - previous_temp) <= 1.0);
         Planet^.hydrosphere:= water;
         Planet^.cloud_cover:= clouds;
         Planet^.ice_cover:= ice;
         Planet^.albedo:= albedo;
         Planet^.surface_temp:= surface_temp;
      End;

@EOF
set `sum $sumopt <enviro.pas`; if test $1 -ne 46285
then
	echo ERROR: enviro.pas checksum is $1 should be 46285
fi
set `wc -lwc <enviro.pas`
if test $1$2$3 != 549258029411
then
	echo ERROR: wc results of enviro.pas are $* should be 549 2580 29411
fi

chmod 644 enviro.pas

echo x - main.pas
cat >main.pas <<'@EOF'
{$R-}    {Range checking off}
{$B+}    {Boolean complete evaluation on}
{$S+}    {Stack checking on}
{$I+}    {I/O checking on}
{$N-}    {No numeric coprocessor}
{$M 65500,16384,655360} {Turbo 3 default stack and heap}

Program Stellar_System_Formation_Simulation;

(*----------------------------------------------------------------------*)
(*                           BIBLIOGRAPHY                               *)
(*  Dole, Stephen H.  "Formation of Planetary Systems by Aggregation:   *)
(*      a Computer Simulation"  October 1969,  Rand Corporation Paper   *)
(*      P-4226, (H31 .R188  #4226 in main lib)                          *)
(*----------------------------------------------------------------------*)

{Uses
  Crt,
  Printer;}

CONST
      eccentricity_coeff = 0.077;   (* Dole's was 0.077         *)
      Protoplanet_mass = 1.0E-15;   (* Units of solar masses    *)
      Solar_mass_in_grams = 1.989E33;  (* Units of grams        *)
      Earth_mass_in_grams = 5.977E27;  (* Units of grams        *)
      Earth_radius = 6.378E6;       (* Units of cm              *)
      Earth_radius_in_km = 6378.0;  (* Units of km              *)
      Earth_acceleration = 981.0;   (* Units of cm/sec2         *)
      Earth_axial_tilt = 23.4;      (* Units of degrees         *)
      Earth_exosphere_temp = 1273.0;(* Units of degrees Kelvin  *)
      Earth_masses_per_solar_mass = 332775.64;
      Earth_effective_temp = 255.0; (* Units of degrees Kelvin  *)
      Earth_albedo = 0.3;
      Earth_area_covered_per_kg_of_cloud = 1.839E-8; { Km2/kg }
      Earth_water_mass_per_area = 3.83E15; { grams per square km }
      Earth_surface_pressure_in_millibars = 1000.0;
      Earth_convection_factor = 0.43; (* from Hart, eq.20         *)
      Freezing_point_of_water = 273.0; (* Units of degrees Kelvin *)
      Days_in_a_year = 365.256;     (* Earth days per Earth year  *)
{         gas_retention_threshold = 6.0;}(* ratio of esc vel to RMS vel *)
      gas_retention_threshold = 5.0;(* ratio of esc vel to RMS vel *)
      gas_giant_albedo = 0.5;       (* albedo of a gas giant      *)
      cloud_albedo = 0.52;
      airless_rocky_albedo = 0.07;
      rocky_albedo = 0.15;
      water_albedo = 0.04;
      airless_ice_albedo = 0.5;
      ice_albedo = 0.7;
      Seconds_per_hour = 3600.0;
      cm_per_AU = 1.495978707E13;   (* number of cm in an AU    *)
      cm_per_km = 1.0E5;            (* number of cm in a km     *)
      cm_per_meter = 100.0;
      millibars_per_bar = 1000.0;
      Kelvin_Celcius_difference = 273.0;
      Grav_constant = 6.672E-8;     (* units of dyne cm2/gram2  *)
      greenhouse_effect_const = 0.93; (* affects inner radius.. *)
      Molar_gas_const = 8314.41;    (* units: g*m2/(sec2*K*mol) *)
      K = 50.0;                     (* K = gas/dust ratio       *)
      B = 1.2E-5;                   (* Used in Crit_mass calc   *)
      Dust_density_coeff = 2.0E-3;  (* A in Dole's paper        *)
      Alpha = 5;                    (* Used in density calcs    *)
      N = 3;                        (* Used in density calcs    *)
      j = 1.46E-19;                 (* Used in day-length calcs (cm2/sec2 g) *)
      incredibly_large_number = 9.9999E37;
(*  Now for a few molecular weights (used for RMS velocity calcs):     *)
(*  This table is from Dole's book "Habitable Planets for Man", p. 38  *)
      atomic_hydrogen = 1.0;           { H   }
      molecular_hydrogen = 2.0;        { H2  }
      helium = 4.0;                    { He  }
      atomic_nitrogen = 14.0;          { N   }
      atomic_oxygen = 16.0;            { O   }
      methane = 16.0;                  { CH4 }
      ammonia = 17.0;                  { NH3 }
      water_vapor = 18.0;              { H2O }
      neon = 20.2;                     { Ne  }
      molecular_nitrogen = 28.0;       { N2  }
      carbon_monoxide = 28.0;          { CO  }
      nitric_oxide = 30.0;             { NO  }
      molecular_oxygen = 32.0;         { O2  }
      hydrogen_sulphide = 34.1;        { H2S }
      argon = 39.9;                    { Ar  }
      carbon_dioxide = 44.0;           { CO2 }
      nitrous_oxide = 44.0;            { N2O }
      nitrogen_dioxide = 46.0;         { NO2 }
      ozone = 48.0;                    { O3  }
      sulphur_dioxide = 64.1;          { SO2 }
      sulphur_trioxide = 80.1;         { SO3 }
      krypton = 83.8;                  { Kr  }
      xenon = 131.3;                   { Xe  }

   TYPE Dust_pointer = ^Dust_bands;
        Dust_bands = Record
                        Inner_edge   : real;
                        Outer_edge   : real;
                        Dust_present : boolean;
                        Gas_present  : boolean;
                        Next_band    : Dust_pointer;
                     End;
        Planet_pointer = ^Planets;
(*	Moon_pointer = ^Moons;*)
        Planets = Record
                     a : real;               { semi-major axis of the orbit (in AU)}
                     e : real;               { eccentricity of the orbit         }
                     mass : real;            { mass (in solar masses)            }
                     gas_giant : boolean;    { TRUE if the planet is a gas giant }
                     orbit_zone : integer;   { the 'zone' of the planet          }
                     radius : real;          { equatorial radius (in km)         }
                     density : real;         { density (in g/cc)                 }
                     orbital_period : real;  { length of the local year (days)   }
                     day : real;             { length of the local day (hours)   }
                     resonant_period : boolean; { TRUE if in resonant rotation   }
                     axial_tilt : integer;   { units of degrees                  }
                     escape_velocity : real; { units of cm/sec                   }
                     surface_accel : real;   { units of cm/sec2                  }
                     surface_grav : real;    { units of Earth gravities          }
                     RMS_velocity : real;    { units of cm/sec                   }
                     molecule_weight : real; { smallest molecular weight retained}
                     volatile_gas_inventory : real;
                     surface_pressure : real;{ units of millibars (mb)           }
                     greenhouse_effect : boolean; { runaway greenhouse effect?   }
                     boil_point : real;      { the boiling point of water (Kelvin)}
                     albedo : real;          { albedo of the planet              }
                     surface_temp : real;    { surface temperature in Kelvin     }
                     hydrosphere : real;     { fraction of surface covered       }
                     cloud_cover : real;     { fraction of surface covered       }
                     ice_cover : real;
{                     atmosphere : integer;   { 9 different types numbered 0 -> 8 }
                     first_moon : planet_pointer;
                     next_planet : planet_pointer;
                  End;
(*        Moons = Record
		   a : real;
		   e : real;
		   mass : real;
		   radius : real;
		   density : real;
		   orbital_period : real;
		   day : real;
		   resonant_period : boolean;
		   escape_velocity : real;
                   surface_accel : real;
		   surface_grav : real;
		   RMS_velocity : real;
		   molecule_weight : real;
		   albedo : real;
                   next_moon : moon_pointer;
		End;*)

(*  These are all of the global variables used during accretion:  *)
   VAR Dust_head : Dust_pointer;
       Planet_head : planet_pointer;
       Dust_left : boolean;

   VAR stellar_mass_ratio, stellar_luminosity_ratio, Main_seq_life,
          age, r_ecosphere, r_greenhouse : real;
       radians_per_rotation : real;
       spin_resonance : boolean;

{$I utils.pas}
{$I accrete.pas}
{$I display.pas}
{$I enviro.pas}

   Procedure init;
      Begin
         randomize;
      End;

   Procedure Generate_stellar_system;
      VAR planet : planet_pointer;
      Begin
         radians_per_rotation:= 2 * pi;
         Stellar_mass_ratio:= Random_number (0.6, 1.3);
         Stellar_luminosity_ratio:= luminosity (stellar_mass_ratio);
         planet := Distribute_planetary_masses (Stellar_mass_ratio, Stellar_luminosity_ratio,
		0.0, Stellar_dust_limit(Stellar_mass_ratio));
         Main_seq_life:= 1.0E10*(stellar_mass_ratio / stellar_luminosity_ratio);
         If (Main_seq_life >= 6E9)
            then Age:= random_number (1E9, 6E9)
            else Age:= random_number (1E9, main_seq_life);
         R_ecosphere:= Sqrt(stellar_luminosity_ratio);
         R_greenhouse:= R_ecosphere * greenhouse_effect_const;
         while (planet <> nil)
          do begin
(*		planet^.first_moon:= Distribute_moon_masses (planet^.mass,
			Stellar_luminosity_ratio, planet^.e,
			0.0, planet_dust_limit(planet^.mass));*)
                planet^.orbit_zone:= Orbital_zone (planet^.a);
                if (planet^.gas_giant)
                   then begin
                           planet^.density:= empirical_density (planet^.mass, planet^.a,
                                                              planet^.gas_giant);
                           planet^.radius:= volume_radius (planet^.mass, planet^.density);
                        end
                   else begin
                           planet^.radius:= Kothari_radius (planet^.mass, planet^.a,
                                           planet^.gas_giant, planet^.orbit_zone);
                           planet^.density:= Volume_density (planet^.mass, planet^.radius);
                        end;
                planet^.orbital_period:= Period (planet^.a, planet^.mass, Stellar_mass_ratio);
                planet^.day:= Day_length (planet^.mass, planet^.radius, planet^.orbital_period,
                                         planet^.e, planet^.gas_giant);
                planet^.resonant_period:= spin_resonance;
                planet^.axial_tilt:= inclination(planet^.a);
                planet^.escape_velocity:= Escape_vel (planet^.mass, planet^.radius);
                planet^.surface_accel:= Acceleration (planet^.mass, planet^.radius);
                planet^.RMS_velocity:= RMS_vel (molecular_nitrogen, planet^.a);
                planet^.molecule_weight:= Molecule_limit(planet^.a, planet^.mass,
                                         planet^.radius);
                if (planet^.gas_giant)
                   then begin
                           planet^.surface_grav:= incredibly_large_number;
                           planet^.greenhouse_effect:= false;
                           planet^.volatile_gas_inventory:= incredibly_large_number;
                           planet^.surface_pressure:= incredibly_large_number;
                           planet^.boil_point:= incredibly_large_number;
                           planet^.hydrosphere:= incredibly_large_number;
                           planet^.albedo:= about(gas_giant_albedo, 0.1);
                           planet^.surface_temp:= incredibly_large_number;
                        end
                   else begin
                           planet^.surface_grav:= gravity(planet^.surface_accel);
                           planet^.greenhouse_effect:= greenhouse(planet^.orbit_zone, planet^.a,
                                                      R_greenhouse);
                           planet^.volatile_gas_inventory:= Vol_Inventory(planet^.mass,
                                 planet^.escape_velocity, planet^.RMS_velocity,
                                 stellar_mass_ratio, planet^.orbit_zone,
                                 planet^.greenhouse_effect);
                           planet^.surface_pressure:= Pressure(planet^.volatil